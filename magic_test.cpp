#include <cstdint>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>

#include "common.h"
#include "magic.h"
#include "random.h"

namespace {
xorshift gen;

uint64_t attempts = 0;
uint64_t magics = 0;

constexpr size_t kMaxMagicTries = 1'000'000;  // Maximum attempts to find a valid magic number
constexpr uint64_t kMaxMagicTableSize = 1ull << 12;  // Needed for rooks on corners
}  // namespace

/**
 *   Generates a random 64-bit unsigned integer with relatively few bits set, but at least 6
 *   bits of the most significant byte. This has shown to produce more suitable magic numbers.
 */
uint64_t randomMagic(SquareSet mask) {
    uint64_t magic;
    do {
        magic = gen() & gen() & gen();  // Evaluation order does not affect the result
    } while ((SquareSet(mask.bits() * magic) & SquareSet(0xff00'0000'0000'0000ull)).size() < 6);
    return magic;
}
/**
 *   Computes the table index for a given set of blockers, magic number, and number of bits.
 */
inline size_t magicTableIndex(SquareSet blocked, uint64_t magic, int bits) {
    return (blocked.bits() * magic) >> (64 - bits);
}

uint64_t checkMagic(SquareSet* targets, SquareSet* blockers, uint64_t magic, SquareSet mask) {
    attempts++;
    SquareSet table[kMaxMagicTableSize];
    int bits = mask.size();  // Theoretically could do better sometimes.
    int maskValues = 1 << bits;
    memset(table, 0, sizeof(SquareSet) * maskValues);  // Initialize the table to zero
    for (int i = 0; i < maskValues; i++) {
        SquareSet& entry = table[magicTableIndex(blockers[i], magic, bits)];
        if (entry.empty())
            entry = targets[i];
        else if (entry != targets[i])
            return 0;  // Collision found, magic is not valid
    }
    return magic;
}

/**
 *   Finds a suitable magic number for a given square and piece type (rook or bishop)
 *   by testing random candidates until one is found that produces unique attack mappings.
 */
uint64_t findMagic(Square square, bool bishop) {
    ++magics;
    auto mask = computeSliderBlockers(square, bishop);

    SquareSet blockers[kMaxMagicTableSize];
    for (int i = 0; i < (1 << mask.size()); ++i) blockers[i] = parallelDeposit(i, mask.bits());

    SquareSet targets[kMaxMagicTableSize];
    for (int i = 0; i < (1 << mask.size()); ++i)
        targets[i] = computeSliderTargets(square, bishop, blockers[i]);

    for (size_t k = 0; k < kMaxMagicTries; ++k)
        if (auto magic = checkMagic(targets, blockers, randomMagic(mask), mask)) return magic;

    throw "Failed to find a magic number for square " + std::to_string(square) +
        (bishop ? " (bishop)" : " (rook)");
}

void generateMagic(std::ostream& out) {
    out << "// This file is generated by " << __FILE__ << ". Do not edit.\n\n";
    out << "#pragma once\n";
    out << "#include <cstdint>\n\n";

    out << "constexpr uint64_t rookMagic[" << kNumSquares << "] = {\n";
    for (auto square : SquareSet::all()) {
        out << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
            << findMagic(square, 0) << "ull,\n";
    }
    out << "};\n\n" << std::dec;

    out << "constexpr uint64_t bishopMagic[" << kNumSquares << "] = {\n";
    for (auto square : SquareSet::all()) {
        out << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
            << findMagic(square, 1) << "ull,\n";
    }
    out << "};\n" << std::dec;
}

/**
 *   Main function that generates and prints magic numbers for all squares for both
 *   rook and bishop pieces.
 */
int main() {
    generateMagic(std::cout);
    std::cerr << "Generated " << attempts << " attempts to find " << magics << " magic numbers.\n";
    std::cerr << "Magic numbers generated successfully.\n";

    return 0;
}