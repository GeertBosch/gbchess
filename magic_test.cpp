#include <cstdint>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>

#include "magic.h"

namespace {
/**
 * The xorshift PRNG provides a balance between quality and performance, and is twice as fast
 * as std::mt19937_64 in overall generation of magic tables. Poor quality would lead to longer
 * search times, or in the worst case an unsuccessful search.
 * See https://www.researchgate.net/publication/5142825_Xorshift_RNGs
 */
struct xorshift {
    xorshift(uint64_t seed) : state(seed) {}
    uint64_t operator()() {
        auto result = state * 0xd989bcacc137dcd5ull;
        state ^= state >> 11;
        state ^= state << 31;
        state ^= state >> 18;
        return result;  // Multiplicative constant for better distribution
    }
    uint64_t state;
};
xorshift gen(0xc1f651c67c62c6e0ull);

uint64_t attempts = 0;
uint64_t magics = 0;

constexpr int kMaxMagicBits = 12;             // Maximum bits for magic numbers
constexpr size_t kMaxMagicTries = 1'000'000;  // Maximum attempts to find a valid magic number
constexpr uint64_t kMaxMagicTableSize = 1ull << kMaxMagicBits;

}  // namespace

/**
 *   Generates a random 64-bit unsigned integer with relatively few bits set, but at least 6
 *   bits of the most significant byte. This has shown to produce more suitable magic numbers.
 */
uint64_t randomMagic(uint64_t mask) {
    uint64_t magic;
    do {
        magic = gen() & gen() & gen();  // Evauation order does not affect the result
    } while (pop_count((mask * magic) & 0xff00'0000'0000'0000ull) < 6);
    return magic;
}

uint64_t checkMagic(uint64_t* targets, uint64_t* blockers, uint64_t magic, uint64_t mask) {
    attempts++;
    uint64_t table[kMaxMagicTableSize];
    int bits = pop_count(mask);  // Theoretically, could do better sometimes.
    int maskValues = 1 << bits;
    memset(table, 0, sizeof(uint64_t) * maskValues);  // Initialize the table to zero
    for (int i = 0; i < maskValues; i++) {
        auto& entry = table[magicTableIndex(blockers[i], magic, bits)];
        if (!entry)
            entry = targets[i];
        else if (entry != targets[i])
            return 0;  // Collision found, magic is not valid
    }
    return magic;
}

/**
 *   Finds a suitable magic number for a given square and piece type (rook or bishop)
 *   by testing random candidates until one is found that produces unique attack mappings.
 */
uint64_t findMagic(int square, bool bishop) {
    ++magics;
    uint64_t mask = computeSliderBlockers(square, bishop);

    uint64_t blockers[kMaxMagicTableSize];
    for (int i = 0; i < (1 << pop_count(mask)); i++) blockers[i] = parallelDeposit(i, mask);

    uint64_t targets[kMaxMagicTableSize];
    for (int i = 0; i < (1 << pop_count(mask)); i++)
        targets[i] = computeSliderTargets(square, bishop, blockers[i]);

    for (size_t k = 0; k < kMaxMagicTries; k++)
        if (auto magic = checkMagic(targets, blockers, randomMagic(mask), mask)) return magic;

    throw "Failed to find a magic number for square " + std::to_string(square) +
        (bishop ? " (bishop)" : " (rook)");
}

/**
 *   Main function that generates and prints magic numbers for all squares for both
 *   rook and bishop pieces.
 */
int main() {
    std::cout << "// This file is generated by magic_test.cpp. Do not edit.\n\n";
    std::cout << "#pragma once\n";
    std::cout << "#include <cstdint>\n\n";
    std::cout << "constexpr uint64_t rookMagic[64] = {\n";
    for (int square = 0; square < 64; square++) {
        std::cout << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
                  << findMagic(square, 0) << "ull,\n";
    }
    std::cout << "};\n\n";

    std::cout << "constexpr uint64_t bishopMagic[64] = {\n";
    for (int square = 0; square < 64; square++) {
        std::cout << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
                  << findMagic(square, 1) << "ull,\n";
    }
    std::cout << "};\n\n";
    std::cerr << "Generated " << attempts << " attempts to find " << magics << " magic numbers.\n";
    std::cerr << "Magic numbers generated successfully.\n";

    return 0;
}