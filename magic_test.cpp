#include <cstdint>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <random>
#include <stdio.h>
#include <stdlib.h>

#include "magic.h"

namespace {
std::mt19937_64 gen(0x3'14159'26535'89793ull);  // Arbitrary 64-bit seed

constexpr int kMaxMagicBits = 12;             // Maximum bits for magic numbers
constexpr size_t kMaxMagicTries = 1'000'000;  // Maximum attempts to find a valid magic number
constexpr uint64_t kMaxMagicTableSize = 1ull << kMaxMagicBits;

}  // namespace

/**
 *   Generates a random 64-bit unsigned integer with relatively few bits set, but at least 6
 *   bits of the most significant byte. This has shown to produce more suitable magic numbers.
 */
uint64_t randomMagic(uint64_t mask) {
    uint64_t magic;
    do {
        magic = gen() & gen() & gen();
    } while (pop_count((mask * magic) & 0xff00'0000'0000'0000ull) < 6);
    return magic;
}

uint64_t checkMagic(uint64_t* targets, uint64_t* blockers, uint64_t magic, uint64_t mask) {
    uint64_t table[kMaxMagicTableSize];
    memset(table, 0, sizeof(table));  // Initialize the table to zero
    int bits = pop_count(mask);       // Theoretically, could do better sometimes.
    int maskValues = 1 << bits;
    for (int i = 0; i < maskValues; i++) {
        auto& entry = table[magicTableIndex(blockers[i], magic, bits)];
        if (!entry)
            entry = targets[i];
        else if (entry != targets[i])
            return 0;  // Collision found, magic is not valid
    }
    return magic;
}

/**
 *   Finds a suitable magic number for a given square and piece type (rook or bishop)
 *   by testing random candidates until one is found that produces unique attack mappings.
 */
uint64_t findMagic(int square, bool bishop) {
    uint64_t mask = computeSliderBlockers(square, bishop);

    uint64_t blockers[kMaxMagicTableSize];
    for (int i = 0; i < (1 << pop_count(mask)); i++) blockers[i] = indexToBlockers(i, mask);

    uint64_t targets[kMaxMagicTableSize];
    for (int i = 0; i < (1 << pop_count(mask)); i++)
        targets[i] = computeSliderTargets(square, bishop, blockers[i]);

    for (size_t k = 0; k < kMaxMagicTries; k++)
        if (auto magic = checkMagic(targets, blockers, randomMagic(mask), mask)) return magic;

    throw "Failed to find a magic number for square " + std::to_string(square) +
        (bishop ? " (bishop)" : " (rook)");
}

/**
 *   Main function that generates and prints magic numbers for all squares for both
 *   rook and bishop pieces.
 */
int main() {
    std::cout << "// This file is generated by magic_test.cpp. Do not edit.\n\n";
    std::cout << "#pragma once\n";
    std::cout << "#include <cstdint>\n\n";
    std::cout << "constexpr uint64_t rookMagic[64] = {\n";
    for (int square = 0; square < 64; square++) {
        std::cout << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
                  << findMagic(square, 0) << "ull,\n";
    }
    std::cout << "};\n\n";

    std::cout << "constexpr uint64_t bishopMagic[64] = {\n";
    for (int square = 0; square < 64; square++) {
        std::cout << "  0x" << std::setfill('0') << std::setw(16) << std::hex << std::nouppercase
                  << findMagic(square, 1) << "ull,\n";
    }
    std::cout << "};\n\n";

    return 0;
}