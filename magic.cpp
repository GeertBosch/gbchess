

#include "magic.h"
#include "common.h"
#include "magic_gen.h"

// The constexpr uint64_t rookMagic[64] and bishopMagic[64] arrays are generated by magic_test.cpp.
// They contain the magic numbers for rook and bishop pieces on each square of the board.

uint64_t parallelDeposit(uint64_t value, uint64_t mask) {
    uint64_t result = 0ull;
    for (uint64_t valueBit = 1; mask; valueBit <<= 1) {
        auto maskBit = mask & -mask;  // Isolate the least significant set bit in mask
        mask -= maskBit;              // Remove it from mask
        result |= value & valueBit ? maskBit : 0;
    }
    return result;
}

namespace {

struct Magic {
    uint64_t magic;               // Magic number for the piece type
    uint64_t mask;                // Bitmask for the piece type
    std::vector<uint64_t> table;  // Precomputed target tables for the piece type
    int shift;                    // Number of bits used for indexing into the table
    Magic(uint8_t square, bool bishop, uint64_t magic)
        : magic(magic), mask(computeSliderBlockers(square, bishop)), shift(pop_count(~mask)) {
        int bits = 64 - shift;
        table.resize(1ull << bits, 0ull);
        for (int i = 0; i < (1 << bits); i++) {
            auto targets = computeSliderTargets(square, bishop, parallelDeposit(i, mask));
            auto blockers = parallelDeposit(i, mask);
            if (auto& entry = table[(blockers * magic) >> shift])
                assert(entry == targets);
            else
                entry = targets;
        }
    }

    // Computes the target square for this square and piece type, given the board occupancy.
    uint64_t targets(uint64_t occupancy) const {
        uint64_t blockers = occupancy & mask;
        size_t index = (blockers * magic) >> shift;
        return table[index];
    }
};

auto rookMagics = []() {
    std::vector<Magic> magics;
    for (int sq = 0; sq < kNumSquares; ++sq) magics.emplace_back(sq, false, rookMagic[sq]);
    return magics;
}();
auto bishopMagics = []() {
    std::vector<Magic> magics;
    for (int sq = 0; sq < kNumSquares; ++sq) magics.emplace_back(sq, true, bishopMagic[sq]);
    return magics;
}();

}  // namespace

uint64_t rookBlockers(uint8_t sq) {
    uint64_t result = 0ull;
    int rank = sq / 8;
    int file = sq % 8;

    for (int r = rank + 1; r <= 6; r++) result |= (1ull << (file + r * 8));
    for (int r = rank - 1; r >= 1; r--) result |= (1ull << (file + r * 8));
    for (int f = file + 1; f <= 6; f++) result |= (1ull << (f + rank * 8));
    for (int f = file - 1; f >= 1; f--) result |= (1ull << (f + rank * 8));
    return result;
}

uint64_t bishopBlockers(uint8_t sq) {
    uint64_t result = 0ull;
    int rank = sq / 8, file = sq % 8;
    for (int r = rank + 1, f = file + 1; r <= 6 && f <= 6; r++, f++)
        result |= (1ull << (f + r * 8));
    for (int r = rank + 1, f = file - 1; r <= 6 && f >= 1; r++, f--)
        result |= (1ull << (f + r * 8));
    for (int r = rank - 1, f = file + 1; r >= 1 && f <= 6; r--, f++)
        result |= (1ull << (f + r * 8));
    for (int r = rank - 1, f = file - 1; r >= 1 && f >= 1; r--, f--)
        result |= (1ull << (f + r * 8));
    return result;
}

uint64_t computeSliderBlockers(uint8_t square, bool bishop) {
    return bishop ? bishopBlockers(square) : rookBlockers(square);
}

/**
 *   Computes the rook attack bitboard for a given square and blocker configuration.
 */
uint64_t computeRookTargets(uint8_t sq, uint64_t blockers) {
    uint64_t result = 0ull;
    int rk = sq / 8, fl = sq % 8, r, f;
    for (r = rk + 1; r <= 7; r++) {
        result |= (1ull << (fl + r * 8));
        if (blockers & (1ull << (fl + r * 8))) break;
    }
    for (r = rk - 1; r >= 0; r--) {
        result |= (1ull << (fl + r * 8));
        if (blockers & (1ull << (fl + r * 8))) break;
    }
    for (f = fl + 1; f <= 7; f++) {
        result |= (1ull << (f + rk * 8));
        if (blockers & (1ull << (f + rk * 8))) break;
    }
    for (f = fl - 1; f >= 0; f--) {
        result |= (1ull << (f + rk * 8));
        if (blockers & (1ull << (f + rk * 8))) break;
    }
    return result;
}

/**
 *   Computes the bishop attack bitboard for a given square and blocker configuration.
 */
uint64_t computeBishopTargets(uint8_t sq, uint64_t blockers) {
    uint64_t result = 0ull;
    int rk = sq / 8, fl = sq % 8, r, f;
    for (r = rk + 1, f = fl + 1; r <= 7 && f <= 7; r++, f++) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk + 1, f = fl - 1; r <= 7 && f >= 0; r++, f--) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk - 1, f = fl + 1; r >= 0 && f <= 7; r--, f++) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk - 1, f = fl - 1; r >= 0 && f >= 0; r--, f--) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    return result;
}

uint64_t computeSliderTargets(uint8_t square, bool bishop, uint64_t blockers) {
    return bishop ? computeBishopTargets(square, blockers) : computeRookTargets(square, blockers);
}

uint64_t targets(uint8_t square, bool bishop, uint64_t occupancy) {
    const auto& magics = bishop ? bishopMagics : rookMagics;
    return magics[square].targets(occupancy);
}