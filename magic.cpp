

#include "magic.h"
#include "common.h"
#include "magic_gen.h"

// The constexpr uint64_t rookMagic[64] and bishopMagic[64] arrays are generated by magic_test.cpp.
// They contain the magic numbers for rook and bishop pieces on each square of the board.

namespace {
auto rookMagics = []() {
    std::vector<Magic> magics;
    for (int sq = 0; sq < kNumSquares; ++sq) magics.emplace_back(sq, false, rookMagic[sq]);
    return magics;
}();
auto bishopMagics = []() {
    std::vector<Magic> magics;
    for (int sq = 0; sq < kNumSquares; ++sq) magics.emplace_back(sq, true, bishopMagic[sq]);
    return magics;
}();

}  // namespace

uint64_t rookBlockers(uint8_t sq) {
    uint64_t result = 0ull;
    int rank = sq / 8;
    int file = sq % 8;

    for (int r = rank + 1; r <= 6; r++) result |= (1ull << (file + r * 8));
    for (int r = rank - 1; r >= 1; r--) result |= (1ull << (file + r * 8));
    for (int f = file + 1; f <= 6; f++) result |= (1ull << (f + rank * 8));
    for (int f = file - 1; f >= 1; f--) result |= (1ull << (f + rank * 8));
    return result;
}

uint64_t bishopBlockers(uint8_t sq) {
    uint64_t result = 0ull;
    int rank = sq / 8, file = sq % 8;
    for (int r = rank + 1, f = file + 1; r <= 6 && f <= 6; r++, f++)
        result |= (1ull << (f + r * 8));
    for (int r = rank + 1, f = file - 1; r <= 6 && f >= 1; r++, f--)
        result |= (1ull << (f + r * 8));
    for (int r = rank - 1, f = file + 1; r >= 1 && f <= 6; r--, f++)
        result |= (1ull << (f + r * 8));
    for (int r = rank - 1, f = file - 1; r >= 1 && f >= 1; r--, f--)
        result |= (1ull << (f + r * 8));
    return result;
}

uint64_t computeSliderBlockers(uint8_t square, bool bishop) {
    return bishop ? bishopBlockers(square) : rookBlockers(square);
}

/**
 *   Computes the rook attack bitboard for a given square and blocker configuration.
 */
uint64_t computeRookTargets(uint8_t sq, uint64_t blockers) {
    uint64_t result = 0ull;
    int rk = sq / 8, fl = sq % 8, r, f;
    for (r = rk + 1; r <= 7; r++) {
        result |= (1ull << (fl + r * 8));
        if (blockers & (1ull << (fl + r * 8))) break;
    }
    for (r = rk - 1; r >= 0; r--) {
        result |= (1ull << (fl + r * 8));
        if (blockers & (1ull << (fl + r * 8))) break;
    }
    for (f = fl + 1; f <= 7; f++) {
        result |= (1ull << (f + rk * 8));
        if (blockers & (1ull << (f + rk * 8))) break;
    }
    for (f = fl - 1; f >= 0; f--) {
        result |= (1ull << (f + rk * 8));
        if (blockers & (1ull << (f + rk * 8))) break;
    }
    return result;
}

/**
 *   Computes the bishop attack bitboard for a given square and blocker configuration.
 */
uint64_t computeBishopTargets(uint8_t sq, uint64_t blockers) {
    uint64_t result = 0ull;
    int rk = sq / 8, fl = sq % 8, r, f;
    for (r = rk + 1, f = fl + 1; r <= 7 && f <= 7; r++, f++) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk + 1, f = fl - 1; r <= 7 && f >= 0; r++, f--) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk - 1, f = fl + 1; r >= 0 && f <= 7; r--, f++) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    for (r = rk - 1, f = fl - 1; r >= 0 && f >= 0; r--, f--) {
        result |= (1ull << (f + r * 8));
        if (blockers & (1ull << (f + r * 8))) break;
    }
    return result;
}

uint64_t computeSliderTargets(uint8_t square, bool bishop, uint64_t blockers) {
    return bishop ? computeBishopTargets(square, blockers) : computeRookTargets(square, blockers);
}

uint64_t targets(uint8_t square, bool bishop, uint64_t occupancy) {
    const auto& magics = bishop ? bishopMagics : rookMagics;
    return magics[square].targets(occupancy);
}