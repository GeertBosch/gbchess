

#include "magic.h"
#include "common.h"
#include "magic_gen.h"

// The constexpr uint64_t rookMagic[64] and bishopMagic[64] arrays are generated by magic_test.cpp.
// They contain the magic numbers for rook and bishop pieces on each square of the board.

uint64_t parallelDeposit(uint64_t value, uint64_t mask) {
    uint64_t result = 0ull;
    for (uint64_t valueBit = 1; mask; valueBit <<= 1) {
        auto maskBit = mask & -mask;  // Isolate the least significant set bit in mask
        mask -= maskBit;              // Remove it from mask
        result |= value & valueBit ? maskBit : 0;
    }
    return result;
}

namespace {

struct Magic {
    uint64_t magic;                // Magic number for the piece type
    SquareSet mask;                // Bitmask for the piece type
    std::vector<SquareSet> table;  // Precomputed target tables for the piece type
    int shift;                     // Number of bits used for indexing into the table
    Magic(Square square, bool bishop, uint64_t magic)
        : magic(magic),
          mask(computeSliderBlockers(square, bishop).bits()),
          shift(64 - mask.size()) {
        int bits = 64 - shift;
        table.resize(1ull << bits, 0ull);
        for (int i = 0; i < (1 << bits); i++) {
            auto targets = computeSliderTargets(square, bishop, parallelDeposit(i, mask.bits()));
            auto blockers = parallelDeposit(i, mask.bits());
            if (auto& entry = table[(blockers * magic) >> shift])
                assert(entry == targets);
            else
                entry = targets;
        }
    }

    // Computes the target square for this square and piece type, given the board occupancy.
    SquareSet targets(SquareSet occupancy) const {
        auto blockers = occupancy & mask;
        size_t index = (blockers.bits() * magic) >> shift;
        return table[index];
    }
};

auto rookMagics = []() {
    std::vector<Magic> magics;
    for (auto square : SquareSet::all()) magics.emplace_back(square, false, rookMagic[square]);
    return magics;
}();
auto bishopMagics = []() {
    std::vector<Magic> magics;
    for (auto square : SquareSet::all()) magics.emplace_back(square, true, bishopMagic[square]);
    return magics;
}();

const int kMaxRank = kNumRanks - 1;
const int kMaxFile = kNumFiles - 1;

}  // namespace

SquareSet rookBlockers(Square sq) {
    SquareSet result;

    // Up, Down, Right, Left
    for (auto to = sq; rank(to) < kMaxRank - 1;) result.insert(to = step(to, 0, 1));
    for (auto to = sq; rank(to) > 1;) result.insert(to = step(to, 0, -1));
    for (auto to = sq; file(to) < kMaxFile - 1;) result.insert(to = step(to, 1, 0));
    for (auto to = sq; file(to) > 1;) result.insert(to = step(to, -1, 0));

    return result;
}

SquareSet bishopBlockers(Square sq) {
    SquareSet result;

    // Up-Right, Up-Left, Down-Right, Down-Left
    for (auto to = sq; rank(to) < kMaxRank - 1 && file(to) < kMaxFile - 1;)
        result.insert(to = step(to, 1, 1));
    for (auto to = sq; rank(to) < kMaxRank - 1 && file(to) > 1;)
        result.insert(to = step(to, -1, 1));
    for (auto to = sq; rank(to) > 1 && file(to) < kMaxFile - 1;)
        result.insert(to = step(to, 1, -1));
    for (auto to = sq; rank(to) > 1 && file(to) > 1;)  //
        result.insert(to = step(to, -1, -1));

    return result;
}

SquareSet computeSliderBlockers(Square square, bool bishop) {
    return bishop ? bishopBlockers(square) : rookBlockers(square);
}

/**
 *   Computes the rook attack bitboard for a given square and blocker configuration.
 */
SquareSet computeRookTargets(Square sq, SquareSet blockers) {
    SquareSet result;

    // Up, Down, Right, Left - stop if we hit a blocker, after inserting that blocker
    for (auto to = sq; rank(to) < kMaxRank;)
        if (blockers.contains((result.insert(to = step(to, 0, 1)), to))) break;
    for (auto to = sq; rank(to) > 0;)
        if (blockers.contains((result.insert(to = step(to, 0, -1)), to))) break;
    for (auto to = sq; file(to) < kMaxFile;)
        if (blockers.contains((result.insert(to = step(to, 1, 0)), to))) break;
    for (auto to = sq; file(to) > 0;)
        if (blockers.contains((result.insert(to = step(to, -1, 0)), to))) break;

    return result;
}

/**
 *   Computes the bishop attack bitboard for a given square and blocker configuration.
 */
SquareSet computeBishopTargets(Square sq, SquareSet blockers) {
    SquareSet result;

    // Up-Right, Up-Left, Down-Right, Down-Left - stop if we hit a blocker, after inserting it
    for (auto to = sq; rank(to) < kMaxRank && file(to) < kMaxFile;)
        if (blockers.contains((result.insert(to = step(to, 1, 1)), to))) break;
    for (auto to = sq; rank(to) < kMaxRank && file(to) > 0;)
        if (blockers.contains((result.insert(to = step(to, -1, 1)), to))) break;
    for (auto to = sq; rank(to) > 0 && file(to) < kMaxFile;)
        if (blockers.contains((result.insert(to = step(to, 1, -1)), to))) break;
    for (auto to = sq; rank(to) > 0 && file(to) > 0;)
        if (blockers.contains((result.insert(to = step(to, -1, -1)), to))) break;

    return result;
}

SquareSet computeSliderTargets(Square square, bool bishop, SquareSet blockers) {
    return bishop ? computeBishopTargets(square, blockers).bits()
                  : computeRookTargets(square, blockers).bits();
}

SquareSet targets(Square square, bool bishop, SquareSet occupancy) {
    const auto& magics = bishop ? bishopMagics : rookMagics;
    return magics[square].targets(occupancy.bits());
}