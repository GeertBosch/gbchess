/**
 * Magic number generator for chess piece attack tables.
 *
 * This program generates magic numbers for rook and bishop pieces on all squares
 * and outputs them as Rust source code. The generated file should be included
 * in the magic module for fast attack lookup during move generation.
 */
use magic::magic::*;
use std::io::{self, Write};

fn generate_magic_file<W: Write>(mut writer: W) -> io::Result<()> {
    writeln!(
        writer,
        "// This file is generated by magic/src/main.rs. Do not edit."
    )?;
    writeln!(writer)?;
    writeln!(
        writer,
        "/// Magic numbers for rook attack lookup on each square"
    )?;
    writeln!(writer, "pub const ROOK_MAGICS: [u64; 64] = [")?;

    let mut rng = XorShift::default();
    let mut total_attempts = 0u64;
    let mut magics_found = 0u64;

    // Generate rook magics for all squares
    for square_idx in 0..64 {
        let square = unsafe { std::mem::transmute(square_idx as u8) };

        if let Some((magic, attempts)) = find_magic(square, false, &mut rng) {
            writeln!(writer, "    0x{:016x},", magic)?;
            magics_found += 1;
            total_attempts += attempts as u64;
        } else {
            panic!(
                "Failed to find magic number for rook on square {}",
                square_idx
            );
        }
    }

    writeln!(writer, "];")?;
    writeln!(writer)?;
    writeln!(
        writer,
        "/// Magic numbers for bishop attack lookup on each square"
    )?;
    writeln!(writer, "pub const BISHOP_MAGICS: [u64; 64] = [")?;

    // Generate bishop magics for all squares
    for square_idx in 0..64 {
        let square = unsafe { std::mem::transmute(square_idx as u8) };

        if let Some((magic, attempts)) = find_magic(square, true, &mut rng) {
            writeln!(writer, "    0x{:016x},", magic)?;
            magics_found += 1;
            total_attempts += attempts as u64;
        } else {
            panic!(
                "Failed to find magic number for bishop on square {}",
                square_idx
            );
        }
    }

    writeln!(writer, "];")?;

    eprintln!(
        "Generated {} attempts to find {} magic numbers.",
        total_attempts, magics_found
    );
    eprintln!("Magic numbers generated successfully.");

    Ok(())
}

fn main() -> io::Result<()> {
    generate_magic_file(io::stdout())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashSet;

    #[test]
    fn test_magic_generation() {
        // Test that we can generate a few magic numbers
        let mut rng = XorShift::new(12345);

        // Test rook magic for a1
        if let Some(magic) = find_magic_simple(Square::A1, false, &mut rng) {
            println!("Found rook magic for A1: 0x{:016x}", magic);
        } else {
            panic!("Failed to find rook magic for A1");
        }

        // Test bishop magic for a1
        if let Some(magic) = find_magic_simple(Square::A1, true, &mut rng) {
            println!("Found bishop magic for A1: 0x{:016x}", magic);
        } else {
            panic!("Failed to find bishop magic for A1");
        }
    }

    #[test]
    fn test_magic_uniqueness() {
        // Test that different squares get different magic numbers
        let mut rng = XorShift::new(54321);
        let mut magics = HashSet::new();

        for i in 0..8 {
            let square = unsafe { std::mem::transmute(i as u8) };
            if let Some(magic) = find_magic_simple(square, false, &mut rng) {
                assert!(magics.insert(magic), "Duplicate magic number found");
            }
        }
    }

    #[test]
    fn test_generated_output_format() {
        // Test that the generated output has the correct format
        let mut buffer = Vec::new();
        generate_magic_file(&mut buffer).unwrap();
        let output = String::from_utf8(buffer).unwrap();

        assert!(output.contains("ROOK_MAGICS"));
        assert!(output.contains("BISHOP_MAGICS"));
        assert!(output.contains("0x"));
        assert!(output.lines().count() > 130); // Should have many lines
    }

    #[test]
    fn test_magic_attempt_counting() {
        // Test that find_magic returns reasonable attempt counts
        let mut rng = XorShift::new(12345);

        // Test a few squares and verify attempt counts are reasonable
        for &square in &[Square::A1, Square::E4, Square::H8] {
            if let Some((magic, attempts)) = find_magic(square, false, &mut rng) {
                assert!(attempts > 0, "Should have made at least one attempt");
                assert!(
                    attempts < 1_000_000,
                    "Shouldn't need maximum attempts for most squares"
                );
                assert!(magic != 0, "Magic number should be non-zero");
                println!(
                    "Square {:?} rook: magic=0x{:016x}, attempts={}",
                    square, magic, attempts
                );
            } else {
                panic!("Failed to find magic for square {:?}", square);
            }
        }
    }
}
